## Eureka

### 1. 基础知识
看视频了解一些概念。
[![Watch the video(https://github.com/YuxingXie/springcloud/raw/master/assets/images/001.jpg)](https://www.youtube.com/embed/tgZ4JyLsm7A?list=PLmOn9nNkQxJGVG1ktTV4SedFWuyef_Pi0)
Q&A

Q:为什么80不能直接访问8001？

    A:因为......
   
Q:什么是服务治理？

    A:(google)服务治理是一个非常宽泛的概念，一般指独立于业务逻辑之外，给系统提供一些可靠运行的系统保障措施。
    针对微服务场景下的常用故障模式，提供的保障措施包括： 负载均衡管理：提供多实例情况下的负载均衡策略管理，
    比如采用轮询的方式保障流量在不同实例均衡。
   
    A:(作者)Spring Cloud封装了Netflix公司开发的Eureka模块来实现服务治理。在传统的rpc远程调用框架中，
    管理每个服务与服务之间依赖关系比较复杂，管理比较复杂，所以需要使用服务治理，管理服务与服务之间的依赖关系，
    可以实现服务调用、负载均衡、容错等，实现服务发现与注册。
   
Q: 什么是服务注册与发现？

    A:看图

   ![](https://github.com/YuxingXie/springcloud/raw/master/assets/images/002.jpg)   
   ![](https://github.com/YuxingXie/springcloud/raw/master/assets/images/003.jpg)    
Q: Eureka有哪两个组件？

    A:看图

   ![](https://github.com/YuxingXie/springcloud/raw/master/assets/images/004.jpg)   

### 2. 单机Eureka的构建

#### 2.1. 创建cloud-eureka-server7001子模块

不多说，用gradle创建。

##### 2.1.1. build.gradle


添加如下依赖：

```groovy

dependencies {
    implementation project(':cloud-project-commons')
//    compile('org.springframework.cloud:spring-cloud-starter-netflix-eureka-server')
    compile('org.springframework.cloud:spring-cloud-starter-netflix-eureka-server:2.2.10.RELEASE')
    compile('org.springframework.cloud:spring-cloud-dependencies:Hoxton.SR1')
    compile('org.springframework.boot:spring-boot-starter-web:2.2.2')
    compile("org.springframework.boot:spring-boot-starter-actuator:2.2.2.RELEASE")
    compile("com.google.code.gson:gson:2.8.2")

    runtime('org.springframework.boot:spring-boot-devtools:2.2.2.RELEASE')
    testCompile("org.springframework.boot:spring-boot-starter-test:2.2.2.RELEASE")
}

```

这里spring-boot和springCloud版本把我整得有点惨，需要匹配。另外com.google.code.gson:gson:2.8.2也必须引入。

    说明：gradle的配置我在之后做了一次彻底的重构，所以这些配置并不是最终配置。

网上找到一个对应关系表：
![](https://github.com/YuxingXie/springcloud/raw/master/assets/images/005.jpg)  
![](https://github.com/YuxingXie/springcloud/raw/master/assets/images/006.jpg)  

##### 2.1.2. application.properties

```properties
server.port=7001

#eureka服务端的实例名称
eureka.instance.hostname=localhost
#false表示不向注册中心注册自己
eureka.client.register-with-eureka=false

#false表示自己端就是注册中心，职责就是维护服务实例，并不需要去检索服务
eureka.client.fetch-registry=false

#设置与eureka server交互的地址查询服务和注册服务都需要依赖这个地址
eureka.client.server-url.defaultZone=http://${eureka.instance.hostname}:${server.port}/eureka/
```

##### 2.1.3. 主启动类

EurekaMain7001.java:
```java
package com.lingyun.study.springcloud;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;
import org.springframework.context.ApplicationListener;
import org.springframework.context.event.ContextRefreshedEvent;

@SpringBootApplication
@EnableEurekaServer
public class EurekaMain7001 implements ApplicationListener<ContextRefreshedEvent> {
        public static void main(String[] args){

                SpringApplication.run(EurekaMain7001.class, args);
        }

        @Override
        public void onApplicationEvent(ContextRefreshedEvent event) {

        }
}

```
访问 http://localhost:7001 ，启动成功！

#### 2.2. 解决springboot与spring-cloud版本不匹配问题

这个问题不得不提出一下，前面的代码eureka8001的冲突解决了，以为后面payment8001不会出问题，但是我天真了。

这个问题真的困扰了我很久，后来我不得不在gitHub上下载了一个eureka example，照着它的设置版本才解决了冲突。

不过这只是临时解决，问题仍然存在，哪天随便哪个版本一变冲突依旧。希望找到系统方案回来补充。

我回来了，解决了。解决的办法就是彻底再深入研究了gradle。

现在，所有子项目（按gradle的习惯不再叫子模块了）的依赖关系都不再在子项目中定义，而在根项目的build.gradle中定义。
如果是maven,那么多模块的pom.xml切换起来都会头晕。

我使用的gradle版本为7.5.1,目前为最新版。

#### 2.3. payment8001入驻进eureka server

1. 主启动类添加注解@EnableEurekaClient。

2. application.properties添加如下内容：
```properties
#false表示不向注册中心注册自己
spring.application.name=cloud-payment-service
eureka.client.register-with-eureka=true

#是否从EurekaServer抓取已有的注册信息，默认为true
eureka.client.fetch-registry=true

#设置与eureka server交互的地址查询服务和注册服务都需要依赖这个地址
eureka.client.service-url.defaultZone=http://localhost:7001/eureka/
```

#### 2.4. order80入驻进eureka server

与3payment8001的操作没什么区别，就不说明了。

记得设置属性spring.application.name=cloud-order-service，如果没有在配置中心页面application栏显示unknown。

另外，为了学习方便，我还是把后面用到的uri的命名改回了和视频一模一样。学习项目不求严格。

### 3. Eureka集群

#### 3.1 集群原理

高可用，互相注册，相互守望

易理解的概念性的东西以后不写了，难点的概念会写一些自己的理解。

#### 3.2 eureka集群环境搭建

#####  3.2.1 创建cloud-eureka-server7002子工程

因为现在我的工程已经是gradle工程，并进行了配置优化，所以将maven的步骤对应为gradle的步骤即可。