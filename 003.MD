
tip:我在之前创建cloud-provider-payment-8001模块的时候没有指定父模块，导致idea认为它是一个顶级模块，后来指定父模块后重建，
结果gradle的工具按钮窗中出现了两个cloud-provider-payment-8001。这个时候只要删除.idea目录再重新打开即可解决。因为项目初创
的时候是选择的maven构建，所以idea侦测到2个框架，选gradle即可。

本章创建一个消费者下订单的模块，这个模块只有api访问的功能。

#### 1 创建子模块

1. 建模块，properties，引依赖，不在话下；

2. 主启动类：OrderMain80.java,不在话下。

#### 2. 业务类

这一步先看完视频。

ok，我感觉到了问题：Payment,CommonResult这些类居然是拷贝支付模块的代码过去的，这。。。如果payment模块改变了Payment类，如何保证
两个模块代码同步？

视频看到后面，作者解决了这个问题，所以我们先不管，在4小节《工程重构》中讲。

Payment拷贝过去，去掉jpa注解，变成一个pojo。

CommonResult拷贝过去,记得加一个无参构造方法，否则后面的restTemplate在返回结果转化为CommonResult时因没有无参构造方法调用而报错。

编写一个OrderRestController。

##### 1. restTemplate说明

因为这个模块只能用来访问api，所以它要通过httpClient来调用。restTemplate是一个httpClient的封装工具。

官网： https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html

在官网浏览一下RestTemplate的构造方法和类方法，感觉非常容易理解。比如
```text
<T> T postForObject(String url, Object request, Class<T> responseType, Map<String,?> uriVariables)

Create a new resource by POSTing the given object to the URI template, and returns the representation found in the response.
```
方法命名，参数，返回值都很容易知道它要干什么。

##### 2. restTemplate注册为spring bean
```java
package com.lingyun.study.springcloud.common;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class ApplicationContextConfig {
    @Bean
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }
}

```

注意RestTemplate的gradle依赖为：org.springframework:spring-web:5.3.23，记得引入。

##### 3. restTemplate注入OrderRestController并编写代码

因为过于容易理解，不解释了。

```java
package com.lingyun.study.springcloud.domain.order.controller;

import com.lingyun.study.springcloud.common.CommonResult;
import com.lingyun.study.springcloud.domain.payment.entity.Payment;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.client.RestTemplate;

@RestController
public class OrderRestController {
    private final String paymentUrl="http://localhost:8001";
    private RestTemplate restTemplate;
    public OrderRestController(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }
    @PostMapping("/api/consumer/payment/create")
    public CommonResult create(@RequestBody Payment payment) {
        return restTemplate.postForEntity(paymentUrl+"/api/payment/create",payment,CommonResult.class).getBody();
    }
    @GetMapping("/api/consumer/payment/detail/{id}")
    public CommonResult findById(@PathVariable Long id){
        return restTemplate.getForEntity(paymentUrl+"/api/payment/detail/"+id,CommonResult.class).getBody();
    }
}
```

不过我用debug和run模式dashboard都没出来,解决方法：

1. Help--> Edit custom VM options...-->增加一条-Dide.run.dashboard=true。
解决了，但是我的idea 2020.1并不叫dashboard而是叫Services。

2. 打开.idea目录中的workspace.xml，找到下面这样的东东：
```xml
<component name="RunDashboard">
    <option name="ruleStates">
      <list>
        <RuleState>
          <option name="name" value="ConfigurationTypeDashboardGroupingRule" />
        </RuleState>
        <RuleState>
          <option name="name" value="StatusDashboardGroupingRule" />
        </RuleState>
      </list>
    </option>
</component>
```

添加这一段在component节点下：
```xml
<option name="configurationTypes">
    <set>
        <option value="SpringBootApplicationConfigurationType" />
    </set>
</option>
```
最终这样子的：
```xml
<component name="RunDashboard">
    <option name="configurationTypes">
        <set>
            <option value="SpringBootApplicationConfigurationType" />
        </set>
    </option>
    <option name="ruleStates">
        <list>
        <RuleState>
            <option name="name" value="ConfigurationTypeDashboardGroupingRule" />
        </RuleState>
        <RuleState>
            <option name="name" value="StatusDashboardGroupingRule" />
        </RuleState>
        </list>
    </option>
</component>
```
我本人打开这个文件的时候，发现里面已经添加了那一段配置，估计是第一个方法生效后自动添加上去的。

##### 4. 工程重构（maven版）

先说说作者的思路：将共用类抽取出来放入一个新的公用模块中，删除老代码，使用mvn install公用模块后，
在需要公共类的模块中maven增加依赖公用模块。我因为用gradle肯定不会使用到maven，但是考虑到maven玩家的福利，
手抄了一份80和8001模块的pom中依赖公用模块的配置片段：

```xml


<dependencies>
    <dependency>
      <!-- 引入自己定义的api通用包，可以使用Payment支付Entity -->
      <group>com.atguigu.springcloud</group>
      <artifactId>cloud-api-commons</artifactId>
      <version>${project.version}</version>
    </dependency>
  
     <dependency>
      <!-- 这个依赖听作者说是处理中文日期的工具，而且很好用。所以也贴一下。 -->
      <group>cn.hutool</group>
      <artifactId>hutool-all</artifactId>
      <version>5.1.0</version>
     </dependency> 
</dependencies>

```

##### 5. 工程重构（gradle版）

gradle中我们的思路当然也是把那些公共类抽取出来。

###### 5.1 新建模块

作者的通用模块名是：cloud-api-commons。

我觉得他的命名有问题，而且也不符合我的需求，这个我后面讲。我的通用模块命名为：cloud-project-commons。


现在要填几个坑：

1. jpa的实体中包含jpa注解配置，如@Entity,@Table,@Column,@ManyToOne等等，这在通用模块中是不需要的；

2. 有些通用模块的类是所有项目共享的，不单单是这个study项目用。我们要将具体项目用的和所有项目通用的分开。

下面逐个解决。

###### 5.2 jpa entity与order80模块共享实体

既然jpa的实体不能照搬copy到通用模块，就要用优雅的方法解决。不想兜圈子，直接代码大家都懂的：

